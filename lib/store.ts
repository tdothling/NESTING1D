import { StockItem, Project, OptimizationResult } from './types';

const STORAGE_KEYS = {
  STOCK: 'nesting-1d-stock',
  PROJECTS: 'nesting-1d-projects',
};

export const getStock = (): StockItem[] => {
  if (typeof window === 'undefined') return [];
  const data = localStorage.getItem(STORAGE_KEYS.STOCK);
  return data ? JSON.parse(data) : [];
};

export const saveStock = (stock: StockItem[]) => {
  if (typeof window === 'undefined') return;
  localStorage.setItem(STORAGE_KEYS.STOCK, JSON.stringify(stock));
};

export const getProjects = (): Project[] => {
  if (typeof window === 'undefined') return [];
  const data = localStorage.getItem(STORAGE_KEYS.PROJECTS);
  return data ? JSON.parse(data) : [];
};

export const saveProjects = (projects: Project[]) => {
  if (typeof window === 'undefined') return;
  localStorage.setItem(STORAGE_KEYS.PROJECTS, JSON.stringify(projects));
};

export const addProject = (project: Project) => {
  const projects = getProjects();
  projects.unshift(project);
  saveProjects(projects);
};

export const updateProject = (project: Project) => {
  const projects = getProjects();
  const index = projects.findIndex((p) => p.id === project.id);
  if (index !== -1) {
    projects[index] = project;
    saveProjects(projects);
  }
};

export const removeProject = (id: string) => {
  const projects = getProjects();
  const filteredProjects = projects.filter((p) => p.id !== id);
  saveProjects(filteredProjects);
};

export const updateStockFromOptimization = (result: OptimizationResult, projectId: string) => {
  const stock = getStock();

  // 1. Consume used stock
  result.bars.forEach(bar => {
    if (bar.sourceId && bar.sourceId !== 'new-standard') {
      const itemIndex = stock.findIndex(s => s.id === bar.sourceId);
      if (itemIndex !== -1) {
        if (stock[itemIndex].quantity > 0) {
          stock[itemIndex].quantity -= 1;
        }
      }
    }
  });

  // Remove items with 0 quantity
  const cleanStock = stock.filter(s => s.quantity > 0);

  // 2. Add reusable scraps back to stock
  // We use the new reusableScrap property which already accounts for maxScrapLength
  // Still applying a small safety filter
  const MIN_SCRAP_LENGTH = 50;

  result.bars.forEach(bar => {
    if (bar.reusableScrap >= MIN_SCRAP_LENGTH) {
      // Check if a similar scrap already exists to group them (with the same origin project)
      const existingScrapIndex = cleanStock.findIndex(s =>
        s.material === bar.material &&
        s.length === bar.reusableScrap &&
        s.isScrap === true &&
        s.originProjectId === projectId
      );

      if (existingScrapIndex !== -1) {
        cleanStock[existingScrapIndex].quantity += 1;
      } else {
        cleanStock.push({
          id: crypto.randomUUID(),
          material: bar.material,
          length: bar.reusableScrap,
          quantity: 1,
          isScrap: true,
          originProjectId: projectId
        });
      }
    }
  });

  saveStock(cleanStock);
};

export const rollbackStock = (projectId: string) => {
  const stock = getStock();
  const project = getProjects().find(p => p.id === projectId);
  if (!project || !project.result) return;

  // 1. Remove scraps generated by this project
  const cleanedStock = stock.filter(s => !(s.isScrap && s.originProjectId === projectId));

  // 2. Add back the stock items that the project consumed
  project.result.bars.forEach(bar => {
    if (bar.sourceId && bar.sourceId !== 'new-standard') {
      const existingIndex = cleanedStock.findIndex(s => s.id === bar.sourceId);
      if (existingIndex !== -1) {
        cleanedStock[existingIndex].quantity += 1;
      } else {
        // Re-create the consumed item if it doesn't exist anymore
        cleanedStock.push({
          id: bar.sourceId,
          material: bar.material,
          length: bar.length,
          quantity: 1,
          isScrap: bar.isScrapUsed,
          // Note: we lose the original originProjectId of the consumed scrap here if it had one, 
          // but it's an edge case we can tolerate for simplicity.
        });
      }
    }
  });

  saveStock(cleanedStock);
};
